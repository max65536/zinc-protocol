import _m0 from "protobufjs/minimal";
export declare const protobufPackage = "gossip.v1";
export interface GossipMessage {
    signedObservation: SignedObservation | undefined;
    signedHeartbeat: SignedHeartbeat | undefined;
    signedVaaWithQuorum: SignedVAAWithQuorum | undefined;
    signedObservationRequest: SignedObservationRequest | undefined;
    signedBatchObservation: SignedBatchObservation | undefined;
    signedBatchVaaWithQuorum: SignedBatchVAAWithQuorum | undefined;
    signedChainGovernorConfig: SignedChainGovernorConfig | undefined;
    signedChainGovernorStatus: SignedChainGovernorStatus | undefined;
}
export interface SignedHeartbeat {
    /** Serialized Heartbeat message. */
    heartbeat: Uint8Array;
    /** ECDSA signature using the node's guardian public key. */
    signature: Uint8Array;
    /**
     * Guardian address that signed this payload (truncated Eth address).
     * This is already contained in Heartbeat, however, we want to verify
     * the payload before we deserialize it.
     */
    guardianAddr: Uint8Array;
}
/** P2P gossip heartbeats for network introspection purposes. */
export interface Heartbeat {
    /** The node's arbitrarily chosen, untrusted nodeName. */
    nodeName: string;
    /** A monotonic counter that resets to zero on startup. */
    counter: string;
    /** UNIX wall time. */
    timestamp: string;
    networks: Heartbeat_Network[];
    /** Human-readable representation of the current bridge node release. */
    version: string;
    /** Human-readable representation of the guardian key's address. */
    guardianAddr: string;
    /** UNIX boot timestamp. */
    bootTimestamp: string;
    /** List of features enabled on this node. */
    features: string[];
}
export interface Heartbeat_Network {
    /** Canonical chain ID. */
    id: number;
    /** Consensus height of the node. */
    height: string;
    /** Chain-specific human-readable representation of the bridge contract address. */
    contractAddress: string;
    /** Connection error count */
    errorCount: string;
}
/**
 * A SignedObservation is a signed statement by a given guardian node
 * that they observed a given event.
 *
 * Observations always result from an external, final event being observed.
 * Examples are emitted messages in finalized blocks on a block or guardian set changes
 * injected by node operators after reaching off-chain consensus.
 *
 * The event is uniquely identified by its hashed (tx_hash, nonce, values...) tuple.
 *
 * Other nodes will verify the signature. Once any node has observed a quorum of
 * guardians submitting valid signatures for a given hash, they can be assembled into a VAA.
 *
 * Messages without valid signature are dropped unceremoniously.
 */
export interface SignedObservation {
    /** Guardian pubkey as truncated eth address. */
    addr: Uint8Array;
    /** The observation's deterministic, unique hash. */
    hash: Uint8Array;
    /** ECSDA signature of the hash using the node's guardian key. */
    signature: Uint8Array;
    /**
     * Transaction hash this observation was made from.
     * Optional, included for observability.
     */
    txHash: Uint8Array;
    /**
     * Message ID (chain/emitter/seq) for this observation.
     * Optional, included for observability.
     */
    messageId: string;
}
/**
 * A SignedVAAWithQuorum message is sent by nodes whenever one of the VAAs they observed
 * reached a 2/3+ quorum to be considered valid. Signed VAAs are broadcasted to the gossip
 * network to allow nodes to persist them even if they failed to observe the signature.
 */
export interface SignedVAAWithQuorum {
    vaa: Uint8Array;
}
/**
 * Any guardian can send a SignedObservationRequest to the network to request
 * all guardians to re-observe a given transaction. This is rate-limited to one
 * request per second per guardian to prevent abuse.
 *
 * In the current implementation, this is only implemented for Solana.
 * For Solana, the tx_hash is the account address of the transaction's message account.
 */
export interface SignedObservationRequest {
    /** Serialized observation request. */
    observationRequest: Uint8Array;
    /** Signature */
    signature: Uint8Array;
    guardianAddr: Uint8Array;
}
export interface ObservationRequest {
    chainId: number;
    txHash: Uint8Array;
}
/**
 * A SignedBatchObservation is a signed statement by a given guardian node
 * that they observed a series of messages originating from a transaction.
 *
 * BatcheObervations are emitted when all the Observations from a tx reach quorum.
 *
 * The event is uniquely identified by its hash (made from hashing all the
 * individual Observation hashes).
 *
 * Messages without valid signature are dropped unceremoniously.
 */
export interface SignedBatchObservation {
    /** Guardian pubkey as truncated eth address. */
    addr: Uint8Array;
    /** The observation batch's deterministic, unique hash. */
    hash: Uint8Array;
    /** ECSDA signature of the hash using the node's guardian key. */
    signature: Uint8Array;
    /** Unique identifier of the transaction that produced the observation. */
    txId: Uint8Array;
    /** Chain ID for this observation. */
    chainId: number;
    /** Nonce of the messages in the batch. */
    nonce: number;
    /** Batch ID - emitterChain/transactionID/nonce */
    batchId: string;
}
export interface SignedBatchVAAWithQuorum {
    /** batch_vaa bytes are the binary encoding of the BatchVAA */
    batchVaa: Uint8Array;
    /** Emitter Chain ID of the messages */
    chainId: number;
    /** Transaction identifier of the observation */
    txId: Uint8Array;
    /** Nonce of the messages in the batch */
    nonce: number;
    /** Batch ID - emitterChain/transactionID/nonce string, for convenience */
    batchId: string;
}
/** This message is published every five minutes. */
export interface SignedChainGovernorConfig {
    /** Serialized ChainGovernorConfig message. */
    config: Uint8Array;
    /** ECDSA signature using the node's guardian key. */
    signature: Uint8Array;
    /** Guardian address that signed this payload (truncated Eth address). */
    guardianAddr: Uint8Array;
}
export interface ChainGovernorConfig {
    nodeName: string;
    counter: string;
    timestamp: string;
    chains: ChainGovernorConfig_Chain[];
    tokens: ChainGovernorConfig_Token[];
}
export interface ChainGovernorConfig_Chain {
    chainId: number;
    notionalLimit: string;
    bigTransactionSize: string;
}
export interface ChainGovernorConfig_Token {
    originChainId: number;
    /** human-readable hex-encoded (leading 0x) */
    originAddress: string;
    price: number;
}
/** This message is published every minute. */
export interface SignedChainGovernorStatus {
    /** Serialized ChainGovernorStatus message. */
    status: Uint8Array;
    /** ECDSA signature using the node's guardian key. */
    signature: Uint8Array;
    /** Guardian address that signed this payload (truncated Eth address). */
    guardianAddr: Uint8Array;
}
export interface ChainGovernorStatus {
    nodeName: string;
    counter: string;
    timestamp: string;
    chains: ChainGovernorStatus_Chain[];
}
export interface ChainGovernorStatus_EnqueuedVAA {
    /** Chain and emitter address are assumed. */
    sequence: string;
    releaseTime: number;
    notionalValue: string;
    txHash: string;
}
export interface ChainGovernorStatus_Emitter {
    /** human-readable hex-encoded (leading 0x) */
    emitterAddress: string;
    totalEnqueuedVaas: string;
    /** Only the first 20 will be included. */
    enqueuedVaas: ChainGovernorStatus_EnqueuedVAA[];
}
export interface ChainGovernorStatus_Chain {
    chainId: number;
    remainingAvailableNotional: string;
    emitters: ChainGovernorStatus_Emitter[];
}
export declare const GossipMessage: {
    encode(message: GossipMessage, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GossipMessage;
    fromJSON(object: any): GossipMessage;
    toJSON(message: GossipMessage): unknown;
    fromPartial(object: DeepPartial<GossipMessage>): GossipMessage;
};
export declare const SignedHeartbeat: {
    encode(message: SignedHeartbeat, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SignedHeartbeat;
    fromJSON(object: any): SignedHeartbeat;
    toJSON(message: SignedHeartbeat): unknown;
    fromPartial(object: DeepPartial<SignedHeartbeat>): SignedHeartbeat;
};
export declare const Heartbeat: {
    encode(message: Heartbeat, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Heartbeat;
    fromJSON(object: any): Heartbeat;
    toJSON(message: Heartbeat): unknown;
    fromPartial(object: DeepPartial<Heartbeat>): Heartbeat;
};
export declare const Heartbeat_Network: {
    encode(message: Heartbeat_Network, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Heartbeat_Network;
    fromJSON(object: any): Heartbeat_Network;
    toJSON(message: Heartbeat_Network): unknown;
    fromPartial(object: DeepPartial<Heartbeat_Network>): Heartbeat_Network;
};
export declare const SignedObservation: {
    encode(message: SignedObservation, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SignedObservation;
    fromJSON(object: any): SignedObservation;
    toJSON(message: SignedObservation): unknown;
    fromPartial(object: DeepPartial<SignedObservation>): SignedObservation;
};
export declare const SignedVAAWithQuorum: {
    encode(message: SignedVAAWithQuorum, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SignedVAAWithQuorum;
    fromJSON(object: any): SignedVAAWithQuorum;
    toJSON(message: SignedVAAWithQuorum): unknown;
    fromPartial(object: DeepPartial<SignedVAAWithQuorum>): SignedVAAWithQuorum;
};
export declare const SignedObservationRequest: {
    encode(message: SignedObservationRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SignedObservationRequest;
    fromJSON(object: any): SignedObservationRequest;
    toJSON(message: SignedObservationRequest): unknown;
    fromPartial(object: DeepPartial<SignedObservationRequest>): SignedObservationRequest;
};
export declare const ObservationRequest: {
    encode(message: ObservationRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ObservationRequest;
    fromJSON(object: any): ObservationRequest;
    toJSON(message: ObservationRequest): unknown;
    fromPartial(object: DeepPartial<ObservationRequest>): ObservationRequest;
};
export declare const SignedBatchObservation: {
    encode(message: SignedBatchObservation, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SignedBatchObservation;
    fromJSON(object: any): SignedBatchObservation;
    toJSON(message: SignedBatchObservation): unknown;
    fromPartial(object: DeepPartial<SignedBatchObservation>): SignedBatchObservation;
};
export declare const SignedBatchVAAWithQuorum: {
    encode(message: SignedBatchVAAWithQuorum, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SignedBatchVAAWithQuorum;
    fromJSON(object: any): SignedBatchVAAWithQuorum;
    toJSON(message: SignedBatchVAAWithQuorum): unknown;
    fromPartial(object: DeepPartial<SignedBatchVAAWithQuorum>): SignedBatchVAAWithQuorum;
};
export declare const SignedChainGovernorConfig: {
    encode(message: SignedChainGovernorConfig, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SignedChainGovernorConfig;
    fromJSON(object: any): SignedChainGovernorConfig;
    toJSON(message: SignedChainGovernorConfig): unknown;
    fromPartial(object: DeepPartial<SignedChainGovernorConfig>): SignedChainGovernorConfig;
};
export declare const ChainGovernorConfig: {
    encode(message: ChainGovernorConfig, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ChainGovernorConfig;
    fromJSON(object: any): ChainGovernorConfig;
    toJSON(message: ChainGovernorConfig): unknown;
    fromPartial(object: DeepPartial<ChainGovernorConfig>): ChainGovernorConfig;
};
export declare const ChainGovernorConfig_Chain: {
    encode(message: ChainGovernorConfig_Chain, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ChainGovernorConfig_Chain;
    fromJSON(object: any): ChainGovernorConfig_Chain;
    toJSON(message: ChainGovernorConfig_Chain): unknown;
    fromPartial(object: DeepPartial<ChainGovernorConfig_Chain>): ChainGovernorConfig_Chain;
};
export declare const ChainGovernorConfig_Token: {
    encode(message: ChainGovernorConfig_Token, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ChainGovernorConfig_Token;
    fromJSON(object: any): ChainGovernorConfig_Token;
    toJSON(message: ChainGovernorConfig_Token): unknown;
    fromPartial(object: DeepPartial<ChainGovernorConfig_Token>): ChainGovernorConfig_Token;
};
export declare const SignedChainGovernorStatus: {
    encode(message: SignedChainGovernorStatus, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SignedChainGovernorStatus;
    fromJSON(object: any): SignedChainGovernorStatus;
    toJSON(message: SignedChainGovernorStatus): unknown;
    fromPartial(object: DeepPartial<SignedChainGovernorStatus>): SignedChainGovernorStatus;
};
export declare const ChainGovernorStatus: {
    encode(message: ChainGovernorStatus, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ChainGovernorStatus;
    fromJSON(object: any): ChainGovernorStatus;
    toJSON(message: ChainGovernorStatus): unknown;
    fromPartial(object: DeepPartial<ChainGovernorStatus>): ChainGovernorStatus;
};
export declare const ChainGovernorStatus_EnqueuedVAA: {
    encode(message: ChainGovernorStatus_EnqueuedVAA, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ChainGovernorStatus_EnqueuedVAA;
    fromJSON(object: any): ChainGovernorStatus_EnqueuedVAA;
    toJSON(message: ChainGovernorStatus_EnqueuedVAA): unknown;
    fromPartial(object: DeepPartial<ChainGovernorStatus_EnqueuedVAA>): ChainGovernorStatus_EnqueuedVAA;
};
export declare const ChainGovernorStatus_Emitter: {
    encode(message: ChainGovernorStatus_Emitter, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ChainGovernorStatus_Emitter;
    fromJSON(object: any): ChainGovernorStatus_Emitter;
    toJSON(message: ChainGovernorStatus_Emitter): unknown;
    fromPartial(object: DeepPartial<ChainGovernorStatus_Emitter>): ChainGovernorStatus_Emitter;
};
export declare const ChainGovernorStatus_Chain: {
    encode(message: ChainGovernorStatus_Chain, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ChainGovernorStatus_Chain;
    fromJSON(object: any): ChainGovernorStatus_Chain;
    toJSON(message: ChainGovernorStatus_Chain): unknown;
    fromPartial(object: DeepPartial<ChainGovernorStatus_Chain>): ChainGovernorStatus_Chain;
};
declare type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
