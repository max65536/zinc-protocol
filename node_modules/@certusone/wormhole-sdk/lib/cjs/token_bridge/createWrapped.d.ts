import { JsonRpcProvider, TransactionBlock } from "@mysten/sui.js";
import { Commitment, Connection, PublicKeyInitData, Transaction } from "@solana/web3.js";
import { MsgExecuteContract } from "@terra-money/terra.js";
import { MsgExecuteContract as XplaMsgExecuteContract } from "@xpla/xpla.js";
import { Algodv2 } from "algosdk";
import { Types } from "aptos";
import { Overrides, ethers } from "ethers";
import { FunctionCallOptions } from "near-api-js/lib/account";
import { Provider } from "near-api-js/lib/providers";
import { TransactionSignerPair } from "../algorand";
import { SignedVaa } from "../vaa";
export declare function createWrappedOnEth(tokenBridgeAddress: string, signer: ethers.Signer, signedVAA: Uint8Array, overrides?: Overrides & {
    from?: string | Promise<string>;
}): Promise<ethers.ContractReceipt>;
export declare function createWrappedOnTerra(tokenBridgeAddress: string, walletAddress: string, signedVAA: Uint8Array): Promise<MsgExecuteContract>;
export declare function createWrappedOnXpla(tokenBridgeAddress: string, walletAddress: string, signedVAA: Uint8Array): XplaMsgExecuteContract;
export declare function createWrappedOnSolana(connection: Connection, bridgeAddress: PublicKeyInitData, tokenBridgeAddress: PublicKeyInitData, payerAddress: PublicKeyInitData, signedVaa: SignedVaa, commitment?: Commitment): Promise<Transaction>;
export declare function createWrappedOnAlgorand(client: Algodv2, tokenBridgeId: bigint, bridgeId: bigint, senderAddr: string, attestVAA: Uint8Array): Promise<TransactionSignerPair[]>;
export declare function createWrappedOnNear(provider: Provider, tokenBridge: string, attestVAA: Uint8Array): Promise<FunctionCallOptions[]>;
/**
 * Constructs payload to create wrapped asset type. The type is of form `{{address}}::coin::T`,
 * where address is `sha256_hash(tokenBridgeAddress | chainID | "::" | originAddress | 0xFF)`.
 *
 * Note that the typical createWrapped call is broken into two parts on Aptos because we must first
 * create the CoinType that is used by `create_wrapped_coin<CoinType>`. Since it's not possible to
 * create a resource and use it in the same transaction, this is broken into separate transactions.
 * @param tokenBridgeAddress Address of token bridge
 * @param attestVAA Bytes of attest VAA
 * @returns Transaction payload
 */
export declare function createWrappedTypeOnAptos(tokenBridgeAddress: string, attestVAA: Uint8Array): Types.EntryFunctionPayload;
/**
 * Constructs payload to create wrapped asset.
 *
 * Note that this function is typically called in tandem with `createWrappedTypeOnAptos` because
 * we must first create the CoinType that is used by `create_wrapped_coin<CoinType>`. Since it's
 * not possible to create a resource and use it in the same transaction, this is broken into
 * separate transactions.
 * @param tokenBridgeAddress Address of token bridge
 * @param attestVAA Bytes of attest VAA
 * @returns Transaction payload
 */
export declare function createWrappedOnAptos(tokenBridgeAddress: string, attestVAA: Uint8Array): Types.EntryFunctionPayload;
export declare function createWrappedOnSuiPrepare(provider: JsonRpcProvider, coreBridgeStateObjectId: string, tokenBridgeStateObjectId: string, decimals: number, signerAddress: string): Promise<TransactionBlock>;
export declare function createWrappedOnSui(provider: JsonRpcProvider, coreBridgeStateObjectId: string, tokenBridgeStateObjectId: string, signerAddress: string, coinPackageId: string, wrappedAssetSetupType: string, attestVAA: Uint8Array, coreBridgePackageId?: string, tokenBridgePackageId?: string): Promise<TransactionBlock>;
