import { AptosAccount, AptosClient, TokenTypes, TxnBuilderTypes, Types } from "aptos";
import { ChainId, ChainName } from "../utils";
/**
 * Generate, sign, and submit a transaction calling the given entry function with the given
 * arguments. Prevents transaction submission and throws if the transaction fails.
 *
 * This is separated from `generateSignAndSubmitScript` because it makes use of `AptosClient`'s
 * `generateTransaction` which pulls ABIs from the node and uses them to encode arguments
 * automatically.
 * @param client Client used to transfer data to/from Aptos node
 * @param sender Account that will submit transaction
 * @param payload Payload containing unencoded fully qualified entry function, types, and arguments
 * @param opts Override default transaction options
 * @returns Data from transaction after is has been successfully submitted to mempool
 */
export declare const generateSignAndSubmitEntryFunction: (client: AptosClient, sender: AptosAccount, payload: Types.EntryFunctionPayload, opts?: Partial<{
    sender: string;
    sequence_number: string;
    max_gas_amount: string;
    gas_unit_price: string;
    expiration_timestamp_secs: string;
    payload: Types.TransactionPayload;
    signature: ({
        type: string;
    } & Types.Ed25519Signature) | ({
        type: string;
    } & Types.MultiEd25519Signature) | ({
        type: string;
    } & {
        sender: ({
            type: string;
        } & Types.Ed25519Signature) | ({
            type: string;
        } & Types.MultiEd25519Signature);
        secondary_signer_addresses: string[];
        secondary_signers: (({
            type: string;
        } & Types.Ed25519Signature) | ({
            type: string;
        } & Types.MultiEd25519Signature))[];
    });
}> | undefined) => Promise<Types.UserTransaction>;
/**
 * Generate, sign, and submit a transaction containing given bytecode. Prevents transaction
 * submission and throws if the transaction fails.
 *
 * Unlike `generateSignAndSubmitEntryFunction`, this function must construct a `RawTransaction`
 * manually because `generateTransaction` does not have support for scripts for which there are
 * no corresponding on-chain ABIs. Type/argument encoding is left to the caller.
 * @param client Client used to transfer data to/from Aptos node
 * @param sender Account that will submit transaction
 * @param payload Payload containing compiled bytecode and encoded types/arguments
 * @param opts Override default transaction options
 * @returns Data from transaction after is has been successfully submitted to mempool
 */
export declare const generateSignAndSubmitScript: (client: AptosClient, sender: AptosAccount, payload: TxnBuilderTypes.TransactionPayloadScript, opts?: Partial<{
    sender: string;
    sequence_number: string;
    max_gas_amount: string;
    gas_unit_price: string;
    expiration_timestamp_secs: string;
    payload: Types.TransactionPayload;
    signature: ({
        type: string;
    } & Types.Ed25519Signature) | ({
        type: string;
    } & Types.MultiEd25519Signature) | ({
        type: string;
    } & {
        sender: ({
            type: string;
        } & Types.Ed25519Signature) | ({
            type: string;
        } & Types.MultiEd25519Signature);
        secondary_signer_addresses: string[];
        secondary_signers: (({
            type: string;
        } & Types.Ed25519Signature) | ({
            type: string;
        } & Types.MultiEd25519Signature))[];
    });
}> | undefined) => Promise<Types.Transaction>;
/**
 * Derives the fully qualified type of the asset defined by the given origin chain and address.
 * @param tokenBridgeAddress Address of token bridge (32 bytes)
 * @param originChain Chain ID of chain that original asset is from
 * @param originAddress Native address of asset; if origin chain ID is 22 (Aptos), this is the
 * asset's fully qualified type
 * @returns The fully qualified type on Aptos for the given asset
 */
export declare const getAssetFullyQualifiedType: (tokenBridgeAddress: string, originChain: ChainId, originAddress: string) => string | null;
/**
 * Derive the module address for an asset defined by the given origin chain and address.
 * @param tokenBridgeAddress Address of token bridge (32 bytes)
 * @param originChain Chain ID of chain that original asset is from
 * @param originAddress Native address of asset
 * @returns The module address for the given asset
 */
export declare const getForeignAssetAddress: (tokenBridgeAddress: string, originChain: ChainId, originAddress: string) => string | null;
/**
 * Test if given string is a valid fully qualified type of moduleAddress::moduleName::structName.
 * @param str String to test
 * @returns Whether or not given string is a valid type
 */
export declare const isValidAptosType: (str: string) => boolean;
/**
 * Hashes the given type. Because fully qualified types are a concept unique to Aptos, this
 * output acts as the address on other chains.
 * @param fullyQualifiedType Fully qualified type on Aptos
 * @returns External address corresponding to given type
 */
export declare const getExternalAddressFromType: (fullyQualifiedType: string) => string;
/**
 * Given a hash, returns the fully qualified type by querying the corresponding TypeInfo.
 * @param client Client used to transfer data to/from Aptos node
 * @param tokenBridgeAddress Address of token bridge
 * @param fullyQualifiedTypeHash Hash of fully qualified type
 * @returns The fully qualified type associated with the given hash
 */
export declare function getTypeFromExternalAddress(client: AptosClient, tokenBridgeAddress: string, fullyQualifiedTypeHash: string): Promise<string | null>;
/**
 * Returns module address from given fully qualified type/module address.
 * @param str FQT or module address
 * @returns Module address
 */
export declare const coalesceModuleAddress: (str: string) => string;
/**
 * The NFT bridge creates resource accounts, which in turn create a collection
 * and mint a single token for each transferred NFT. This method derives the
 * address of that resource account from the given origin chain and address.
 * @param nftBridgeAddress
 * @param originChain
 * @param originAddress External address of NFT on origin chain
 * @returns Address of resource account
 */
export declare const deriveResourceAccountAddress: (nftBridgeAddress: string, originChain: ChainId | ChainName, originAddress: Uint8Array) => Promise<string | null>;
/**
 * Get a hash that uniquely identifies a collection on Aptos.
 * @param tokenId
 * @returns Collection hash
 */
export declare const deriveCollectionHashFromTokenId: (tokenId: TokenTypes.TokenId) => Promise<Uint8Array>;
/**
 * Get a hash that uniquely identifies a token on Aptos.
 *
 * Native tokens in Aptos are uniquely identified by a hash of creator address,
 * collection name, token name, and property version. This hash is converted to
 * a bigint in the `tokenId` field in NFT transfer VAAs.
 * @param tokenId
 * @returns Token hash identifying the token
 */
export declare const deriveTokenHashFromTokenId: (tokenId: TokenTypes.TokenId) => Promise<Uint8Array>;
/**
 * Get creator address, collection name, token name, and property version from
 * a token hash. Note that this method is meant to be used for native tokens
 * that have already been registered in the NFT bridge.
 *
 * The token hash is stored in the `tokenId` field of NFT transfer VAAs and
 * is calculated by the operations in `deriveTokenHashFromTokenId`.
 * @param client
 * @param nftBridgeAddress
 * @param tokenHash Token hash
 * @returns Token ID
 */
export declare const getTokenIdFromTokenHash: (client: AptosClient, nftBridgeAddress: string, tokenHash: Uint8Array) => Promise<TokenTypes.TokenId>;
