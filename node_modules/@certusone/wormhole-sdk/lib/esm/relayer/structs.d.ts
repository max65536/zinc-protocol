/// <reference types="node" />
import { BigNumber } from "ethers";
export declare enum RelayerPayloadId {
    Delivery = 1,
    Redelivery = 2
}
export declare enum ExecutionInfoVersion {
    EVM_V1 = 0
}
export declare enum DeliveryStatus {
    WaitingForVAA = "Waiting for VAA",
    PendingDelivery = "Pending Delivery",
    DeliverySuccess = "Delivery Success",
    ReceiverFailure = "Receiver Failure",
    ForwardRequestSuccess = "Forward Request Success",
    ForwardRequestFailure = "Forward Request Failure",
    ThisShouldNeverHappen = "This should never happen. Contact Support.",
    DeliveryDidntHappenWithinRange = "Delivery didn't happen within given block range"
}
export declare enum RefundStatus {
    RefundSent = "Refund Sent",
    RefundFail = "Refund Fail",
    CrossChainRefundSent = "Cross Chain Refund Sent",
    CrossChainRefundFailProviderNotSupported = "Cross Chain Refund Fail - Provider does not support the refund chain",
    CrossChainRefundFailNotEnough = "Cross Chain Refund Fail - Refund too low for cross chain refund"
}
export declare function parseRefundStatus(index: number): RefundStatus;
export interface VaaKey {
    chainId: number;
    emitterAddress: Buffer;
    sequence: BigNumber;
}
export interface DeliveryInstruction {
    targetChainId: number;
    targetAddress: Buffer;
    payload: Buffer;
    requestedReceiverValue: BigNumber;
    extraReceiverValue: BigNumber;
    encodedExecutionInfo: Buffer;
    refundChainId: number;
    refundAddress: Buffer;
    refundDeliveryProvider: Buffer;
    sourceDeliveryProvider: Buffer;
    senderAddress: Buffer;
    vaaKeys: VaaKey[];
}
export interface RedeliveryInstruction {
    deliveryVaaKey: VaaKey;
    targetChainId: number;
    newRequestedReceiverValue: BigNumber;
    newEncodedExecutionInfo: Buffer;
    newSourceDeliveryProvider: Buffer;
    newSenderAddress: Buffer;
}
declare type StringLeaves<Type> = string | string[] | {
    [P in keyof Type]: StringLeaves<Type[P]>;
};
export declare type DeliveryInstructionPrintable = {
    [Property in keyof DeliveryInstruction]: StringLeaves<DeliveryInstruction[Property]>;
};
export declare type RedeliveryInstructionPrintable = {
    [Property in keyof RedeliveryInstruction]: StringLeaves<RedeliveryInstruction[Property]>;
};
export interface EVMExecutionInfoV1 {
    gasLimit: BigNumber;
    targetChainRefundPerGasUnused: BigNumber;
}
export declare enum VaaKeyType {
    EMITTER_SEQUENCE = 0,
    VAAHASH = 1
}
export declare function parseWormholeRelayerPayloadType(stringPayload: string | Buffer | Uint8Array): RelayerPayloadId;
export declare function createVaaKey(chainId: number, emitterAddress: Buffer, sequence: number | BigNumber): VaaKey;
export declare function parseWormholeRelayerSend(bytes: Buffer): DeliveryInstruction;
export declare function parseEVMExecutionInfoV1(bytes: Buffer, idx: number): [EVMExecutionInfoV1, number];
export declare function parseWormholeRelayerResend(bytes: Buffer): RedeliveryInstruction;
export declare function executionInfoToString(encodedExecutionInfo: Buffer): string;
export declare function deliveryInstructionsPrintable(ix: DeliveryInstruction): DeliveryInstructionPrintable;
export declare function vaaKeyPrintable(ix: VaaKey): StringLeaves<VaaKey>;
export declare function redeliveryInstructionPrintable(ix: RedeliveryInstruction): RedeliveryInstructionPrintable;
export declare type DeliveryOverrideArgs = {
    newReceiverValue: BigNumber;
    newExecutionInfo: Buffer;
    redeliveryHash: Buffer;
};
export declare function packOverrides(overrides: DeliveryOverrideArgs): string;
export declare function parseForwardFailureError(bytes: Buffer): string;
export declare function parseOverrideInfoFromDeliveryEvent(bytes: Buffer): DeliveryOverrideArgs;
export declare function dbg<T>(x: T, msg?: string): T;
export {};
