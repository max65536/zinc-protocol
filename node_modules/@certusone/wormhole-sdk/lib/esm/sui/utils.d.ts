import { JsonRpcProvider, RawSigner, SuiObjectResponse, SuiTransactionBlockResponse, TransactionBlock } from "@mysten/sui.js";
import { SuiError } from "./types";
export declare const uint8ArrayToBCS: (arr: Uint8Array) => Uint8Array;
export declare const executeTransactionBlock: (signer: RawSigner, transactionBlock: TransactionBlock) => Promise<SuiTransactionBlockResponse>;
export declare const getEmitterAddressAndSequenceFromResponseSui: (originalCoreBridgePackageId: string, response: SuiTransactionBlockResponse) => {
    emitterAddress: string;
    sequence: string;
};
export declare const getFieldsFromObjectResponse: (object: SuiObjectResponse) => Record<string, any> | null;
export declare const getInnerType: (type: string) => string | null;
export declare const getObjectFields: (provider: JsonRpcProvider, objectId: string) => Promise<Record<string, any> | null>;
export declare const getOriginalPackageId: (provider: JsonRpcProvider, stateObjectId: string) => Promise<string | undefined>;
export declare const getOwnedObjectId: (provider: JsonRpcProvider, owner: string, type: string) => Promise<string | null>;
export declare const getOwnedObjectIdPaginated: (provider: JsonRpcProvider, owner: string, type: string, cursor?: string | undefined) => Promise<string | null>;
/**
 * @param provider
 * @param objectId Core or token bridge state object ID
 * @returns The latest package ID for the provided state object
 */
export declare function getPackageId(provider: JsonRpcProvider, objectId: string): Promise<string>;
export declare const getPackageIdFromType: (type: string) => string | null;
export declare const getTableKeyType: (tableType: string) => string | null;
export declare const getTokenCoinType: (provider: JsonRpcProvider, tokenBridgeStateObjectId: string, tokenAddress: Uint8Array, tokenChain: number) => Promise<string | null>;
export declare const getTokenFromTokenRegistry: (provider: JsonRpcProvider, tokenBridgeStateObjectId: string, tokenType: string) => Promise<SuiObjectResponse>;
/**
 * This function returns the object ID of the `UpgradeCap` that belongs to the
 * given package and owner if it exists.
 *
 * Structs created by the Sui framework such as `UpgradeCap`s all have the same
 * type (e.g. `0x2::package::UpgradeCap`) and have a special field, `package`,
 * we can use to differentiate them.
 * @param provider Sui RPC provider
 * @param owner Address of the current owner of the `UpgradeCap`
 * @param packageId ID of the package that the `UpgradeCap` was created for
 * @returns The object ID of the `UpgradeCap` if it exists, otherwise `null`
 */
export declare const getUpgradeCapObjectId: (provider: JsonRpcProvider, owner: string, packageId: string) => Promise<string | null>;
/**
 * Get the fully qualified type of a wrapped asset published to the given
 * package ID.
 *
 * All wrapped assets that are registered with the token bridge must satisfy
 * the requirement that module name is `coin` (source: https://github.com/wormhole-foundation/wormhole/blob/a1b3773ee42507122c3c4c3494898fbf515d0712/sui/token_bridge/sources/create_wrapped.move#L88).
 * As a result, all wrapped assets share the same module name and struct name,
 * since the struct name is necessarily `COIN` since it is a OTW.
 * @param coinPackageId packageId of the wrapped asset
 * @returns Fully qualified type of the wrapped asset
 */
export declare const getWrappedCoinType: (coinPackageId: string) => string;
export declare const isSameType: (a: string, b: string) => boolean;
export declare const isSuiError: (error: any) => error is SuiError;
/**
 * This method validates any Sui address, even if it's not 32 bytes long, i.e.
 * "0x2". This differs from Mysten's implementation, which requires that the
 * given address is 32 bytes long.
 * @param address Address to check
 * @returns If given address is a valid Sui address or not
 */
export declare const isValidSuiAddress: (address: string) => boolean;
export declare const isValidSuiType: (type: string) => boolean;
/**
 * Unlike `trimSuiType`, this method does not modify nested types, it just pads
 * the top-level type.
 * @param type
 * @returns
 */
export declare const padSuiType: (type: string) => string;
/**
 * This method removes leading zeroes for types in order to normalize them
 * since some types returned from the RPC have leading zeroes and others don't.
 */
export declare const trimSuiType: (type: string) => string;
/**
 * Create a new EmitterCap object owned by owner.
 * @returns The created EmitterCap object ID
 */
export declare const newEmitterCap: (coreBridgePackageId: string, coreBridgeStateObjectId: string, owner: string) => TransactionBlock;
export declare const getOldestEmitterCapObjectId: (provider: JsonRpcProvider, coreBridgePackageId: string, owner: string) => Promise<string | null>;
